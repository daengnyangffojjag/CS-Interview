# SQL vs NoSQL

> Not Only SQL
> 

웹이 성장하면서 이미지, 동영상 같은 멀티미디어 데이터뿐 아니라, SNS를 통해 작성되는 다양한 형태의 텍스트와 로그 기록 같은 다양한 유형의 비정형 데이터가 빠른 속도로 대량 생산되고 있다. 이런 환경에서 관계형 데이터베이스는 한계가 있으며, 대량의 비정형 데이터의 저장과 처리를 위해 새로운 대안으로 제시된 것이 NoSQL이다.

### 관계형 데이터베이스의 장점

- 정형화된 데이터를 저장 : 데이터의 형태와 크기를 미리 정하고 테이블 단위로 구분하여 데이터를 저장
- 트랜잭션을 통해 ACID를 보장하여 안정적인 데이터 관리
- 조인을 포함해 복잡한 조건을 포함하는 데이터 검색이 가능

### 관계형 데이터베이스의 단점

- 다양한 유형의 비정형 데이터를 저장하기에는 비용이 많이 든다.
- 클러스터 환경에서 확장성이 떨어진다.
    - 클러스터 환경 : 여러 컴퓨터가 연결되어 하나의 시스템을 구성

### NoSQL의 장점

1️⃣ **유연성**

NoSQL은 스키마가 없어서 미리 데이터구조를 정의할 필요가 없고, 있더라도 그 구조를 쉽게 바꿀 수 있다. 반정형 및 비정형 데이터를 저장하는데 적합하다.

2️⃣ **확장성**

NoSQL scale-up 대신 분산형 하드웨어 클러스터를 이용해 확장하도록 설계되어 있다. 저렴한 비용으로 여러 대의 컴퓨터에 데이터를 분산, 저장, 처리하는 것이 가능하다. 대부분 오픈 소스이다.

3️⃣ **고성능**

자료 구조를 원하는 대로 정의할 수 있기 때문에 데이터를 애플리케이션에 더 가깝게 만들 수 있다. RDBMS보다 데이터를 읽어오는 속도가 빠르다.

### NoSQL의 단점

- SQL처럼 복잡한 조건으로 검색하긴 어렵고, 데이터 마이닝과 같은 별도 분석 기술 필요
    - 데이터 마이닝 : 대량의 데이터 안에 숨겨진 지식을 발견하기 위해 규칙과 패턴을 찾아내는 기술 (분류 분석, 군집 분석, 연관 분석 등)
- 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한 번만 수행이 가능)

| 구분 | 관계 데이터베이스 | NoSQL |
| --- | --- | --- |
| 처리 데이터 | 정형 데이터 | 정형 데이터, 비정형(반정형 포함) 데이터 |
| 대용량 데이터 | 대용량 처리 시 성능 저하 | 대용량 데이터 처리 지원 |
| 스키마 | 미리 정해진 스키마가 존재 | 스키마가 없거나 변경이 자유로움 |
| 트랜잭션 | 트랜잭션을 통해 일관성 유지(ACID)를 보장 | 트랜잭션을 지원하지 않아 일관성 유지를 보장하기 어려움 |
| 검색 기능 | 조인 등 복잡한 검색 기능 제공 | 단순한 데이터 검색 기능 (Key-Value) |
| 확장성 | 클러스터 환경에 적합하지 않음 | 클러스터 환경에 적합함 |
| 라이선스 | 고가의 라이선스 비용 | 오픈 소스 |
| 대표 사례 | Oracle, MySQL, MS SQL 서버 등 | 카산드라, 몽고DB, H베이스 |

## NoSQL의 종류

NoSQL은 어떤 데이터 모델로 데이터를 저장하는냐에 따라 네 가지로 분류할 수 있다.

### 1️⃣ 키 - 값 데이터베이스 (Key - Value)

가장 단순한 형태로, 키와 값의 쌍으로 데이터가 저장된다. 이미지, 동영상은 물론 어떠한 형태의 값도 저장할 수 있고, 질의 처리 속도도 빠르다. 키를 통해 검색 가능하며, 값의 일부를 검색하거나 값의 내용을 이용한 질의는 할 수 없고 별도의 처리가 필요하다.

예) 아마존의 다이나모DB, Redis

### 2️⃣ 문서 기반 데이터베이스 (Document-based)

키와 문서를 쌍으로 데이터를 저장한다. 키-값 모델과 달리 트리 형태의 계층적 구조가 존재하는 JSON, XML 등과 같은 반정형 형태의 문서로 데이터를 저장한다. 문서는 객체지향에서 객체의 개념과 유사하다. 키를 통해 문서 전체를 검색하는 것도 가능하지만 XQuery와 같은 특별한 문서 대산 질의 언어를 이용하면 문서 내의 일부를 검색하거나 질의에 활용할 수 있다.

예) 몽고DB, 카우치DB

### 3️⃣ 컬럼 기반 데이터베이스 (Column-based)

컬럼 패밀지와 키의 쌍으로 데이터를 저장한다. 

- 컬럼 패밀리 : 테이블에서 1개의 행을 구성하는 속성들의 모임
- 키 : 각 행을 구분하는 키

관계형 데이터베이스와 다른 점은 행마다 컬럼 구성을 다르게 할 수 있다.

예) 구글의 빅테이블, H베이스, 카산드라

### 4️⃣ 그래프 기반 데이터베이스 (Graph-based)

데이터 간의 관계를 표현하는데 적합하다. 노드에 데이터를 저장하고 간선으로 데이터 간의 관계를 표현하는 그래프 형태로, 질의는 그래프 순회 과정을 통해 처리한다. 다른 NoSQL과 달리 트랜잭션을 통해 ACID를 지원하며, 클러스터 환경에는 적합하지 않다. 연관 데이터를 추천해주거나 소셜 네트워크에서 친구 찾기 질의를 수행하는데 적합하다.

예) 네오포제이, 오리엔트DB, 아젠스그래프

## BASE

전반적으로 NoSQL은 Consistency를 희생하여 속도와 확정성을 선택하긴 했지만, RDBMS의 ACID가 있다면, NoSQL에는 BASE가 있다. 

- **Basically Available**
    
    기본적으로 가용하는 원칙으로 데이터베이스 서버에 장애가 발생해도 백업 서버 등으로 가용성을 유지해야 한다.
    
- **Soft State**
    
    데이터베이스의 데이터는 애플리케이션과 직접 상호작용하지 않아도 일관성을 맞추면서 변경될 수 있다는 원칙이다. 확장된 다른 데이터베이스에서 일어난 변경 사항을 현재 데이터베이스에도 자동으로 반영하여 최종적인 일관성(eventual consistency)을 보장한다.
    
- **Eventual Consistency**
    
    RDBMS의 immediate consistency와는 달리 최종적인 일관성을 유지한다는 원칙이다. 현재 데이터베이스에 변화가 있으면 최종적으로 복제 (replication)을 거치면서 모든 데이터베이스들이 동일한 데이터를 갖게 된다. (일부는 트랜잭션 제공)
    

## NoSQL 활용

- 정확한 데이터 구조를 알 수 없거나 변경/확장될 수 있는 경우
- 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
- 스케일 아웃을 통해 막대한 양의 데이터를 빠르게 처리해야 할 때

### 참고

[https://velog.io/@park2348190/언제-NoSQL을-사용하는게-좋을까](https://velog.io/@park2348190/%EC%96%B8%EC%A0%9C-NoSQL%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B2%8C-%EC%A2%8B%EC%9D%84%EA%B9%8C)

### 질문

1. NoSQL과 관계형 데이터베이스의 차이는?
    
    **RDBMS**
    
    - 장점 : 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
    - 단점 : 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다 (Scale-up만 가능)
    
    **NoSQL**(Not Only SQL)
    
    - **장점** : 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.
        
        데이터 분산이 용이하여 성능 향상을 위한 scale-up, scale-out이 가능하다.
        
    - **단점** : 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다. 데이터를 중복으로 저장하고 이를 업데이트해야 한다.
2. 각각의 사용하는 상황은?
    
    **SQL를 사용해야 할 경우:**
    
    - 데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우
    - 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템
    - 복잡한 쿼리나 리포트를 만들어내야 하는 경우
    - 데이터가 크게 쌓이게 될 여지가 별로 없는 경우(데이터가 많으면 압도적으로 NoSQL이 빠름)
    
    **NoSQL을 사용해야 할 경우**
    
    - 정확한 데이터 구조를 알 수 없거나 변경/확장될 수 있는 경우
    - 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
    - 스케일 아웃을 통해 막대한 양의 데이터를 빠르게 처리해야 할 때
