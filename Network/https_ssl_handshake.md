# HTTPS(Secure HTTP)
### HTTP 란?
Hypertext Transfer Protocol의 약자로 Hypertext 문서인 HTML을 전송하기 위한 통신 규약이다.
> Hypertext란 정보를 담고 있는 문서/파일
ex. html


암호화되지 않은 방법으로 데이터를 송수신하고 제 3자에 의한 메시지 감청이 매우 쉽다.
![](https://velog.velcdn.com/images/tkdtkd97/post/a612aea2-e13f-404c-82ee-06cbbbae8d06/image.png)
![](https://velog.velcdn.com/images/tkdtkd97/post/cfd16669-e590-40f0-a7b6-cfc43dbd0822/image.png)

예를들어 위의 사진에서 중간에 선 하나 따서 내 컴퓨터로 보면 암호화가 되어있지 않기 때문에 감청을 쉽게 할 수 있다.

[wireshark](https://www.wireshark.org)등 다양한 Tool 사용하면 누구나 훔쳐볼 수 있다.

그래서 HTTP의 단점을 보완해서 HTTPS를 사용하게 되었다.

### HTTPS 란?
Hypertext Transfer Protocol Over SSL (Secure Socket Layer)의 약자로 아래의 3가지 특징을 갖는다.

1. HTTPS는 HTTP와 별개의 프로토콜이 아닌 HTTP가 extension(확장)된것이다

2. HTTPS는 인터넷에서 secure communication(보안 통신)을 위해 사용된다

3. Transport Layer Security(TLS) 또는 Secure Sockets Layer(SSL)을 사용해 암호화된다

즉, SSL/TLS을 사용해 암호화하여 보안 통신을 제공하는 HTTP의 확장된 버전이다.

### SSL란?

SSL/TLS는 컴퓨터 네트워크 상에서 보안 통신을 제공하기 위해 설계된 프로토콜이다.

SSL/TLS는 특정 네트워크 계층에 속하는 프로토콜이 아니라, 독자적으로 존재하는 프로토콜이다. 정확하게는 응용 계층(Application Layer)과 전송 계층(Transport Layer) 사이에 위치해, 보안 과정을 수행한다.

HTTPS는 응용 계층 프로토콜인 HTTP와 전송 계층 프로토콜인 TCP 사이에 SSL/TLS 프로토콜을 거치도록 설계되어 있다.
> 외부로 데이터를 보낼 때는 HTTP가 TCP에 보내는 것처럼 데이터를 SSL에게 보내면, SSL이 데이터를 암호화하여 TCP에게 전달한다. 역으로 데이터를 받을 때도 TCP가 HTTP 대신 SSL에게 데이터를 보내면, SSL이 데이터를 복호화하여 HTTP에게 전달한다.

![](https://velog.velcdn.com/images/tkdtkd97/post/fb0574bb-fc8e-4b9b-bc28-c69f1968c498/image.png)

### SSL/TLS Layer
![](https://velog.velcdn.com/images/tkdtkd97/post/e3d65622-5f4a-443e-933e-6ccf56d3a64b/image.png)

### SSL/TLS의 관계
SSL(Secure Socket Layer)은 Netscape에 의해 1995년 개발

SSL 대중화 (SSL 1.0 -> 2.0 -> 3.0)

SSL 관리 주체 변경 ( -> IETF)

IETF는 SSL 기술을 이용해 1999년에 TLS (Transport Layer Security) 정의, 현재 표준이 됨

SSL 3.0 과 TLS 1.0 같은 것입니다.

하지만, 개발자들은 역사적 유래로 SSL 이라는 용어를 더 많이 사용하는 경향이 있습니다.

같은 것으로 생각해도 무방

### HTTPS는 SSL 같은것일까?
HTTPS와 SSL를 같은 의미로 혼동하는 경우가 많다.

일반 사람들이 인터넷과 웹이 같은 것이라고 생각하는 경우와 비슷하다

인터넷 위에서 웹이 작동하는 것 처럼 SSL 위에서 HTTPS가 작동한다고 생각해야 한다

# 대칭키 vs 비대칭키
대칭키와 비대칭키는 모두 문서를 암호화하여 송수신하는 목적을 가진다.

하지만 동작방식이 다르기 때문에 각각 어떤 특징을 갖는지 알아보자

### 대칭키
![](https://velog.velcdn.com/images/tkdtkd97/post/244a82d8-101b-4dce-b399-97e52e0f2b96/image.png)

#### 특징
- 1개의 동일한 대칭키를 사용한다.
- 대칭키로 암호화와 복호화 모두 처리한다.
- 송수신할때 대칭키를 전달해야한다.

#### 송수신 과정
1. 송신자는 문서를 대칭키로 암호화한다.
2. 암호화한 문서와 대칭키를 송신자에게 전달한다.
3. 송신자는 받은 대칭키로 문서를 복호화해서 사용한다.
4. 반대의 경우 동일하다.

#### 장단점
장점
- 비대칭키와 비교해서 문서를 암호화하여 송수신하는 과정에서 속도가 빠르다.

단점
- 송수신중에 대칭키를 상대에게 전달해야한다. 그 과정에서 대칭키가 탈취되면 제 3자에게 문서가 노출되고 변형될 가능성이 있다.
- 전달 경로가 길수록 위험부담이 늘어난다.

### 비대칭키
![](https://velog.velcdn.com/images/tkdtkd97/post/e0d722ee-4d5d-42ae-ae4e-87712ad19f0a/image.png)
#### 특징
- 비대칭키는 쌍을 이루어 암호화, 복호화를 한다.
> 공개키로 암호화하면 비밀키로 복호화할 수 있고 비밀키로 암호화하면 공개키로 복호화할 수 있다.
- 공개키는 외부에 공개하고 비밀키는 외부로 유출하지 않는다.
> 공개키는 왜 외부에 유출해도 상관없을까?
비대칭키는 쌍을 이루어 암호화와 복호화를 한다는 특징이 있다. 그래서 하나의 키로는 문서를 복호화 할 수 없으니 하나는 노출되도 상관이 없고, 대칭키의 단점인 키를 전달하는 중의 리스크를 없애는 효과로 작용할 수 있다.

#### 송수신 과정
1. 송신자와 수신자는 각각 비대칭키 쌍을 생성한다.
   <송신자의 공개키, 송신자의 비밀키> <수신자의 공개키, 수신자의 비밀키>
2. 서로의 공개키를 상대에게 전달한다.
3. 송신자는 상대에게 받은 수신자의 공개키로 문서를 암호화해서 전달한다.
4. 수신자는 자신의 공개키로 암호화된 문서를 받고 자신의 비밀키로 복호화해서 문서를 확인한다.

#### 장단점
장점
- 대칭키와 다르게 자신이 비밀키만 잘 보관하고 있다면 송수신하는 과정에서 키가 탈취될 위험부담이 없다.(보안성이 높다)
- 인증서 역할을 수행할 수 있다.
> 비대칭키 방식은 송수신과정에 본것처럼 기능하는 경우가 통상적이지만 반대로 수신자에게 내가 안전한 송신자(해커가 아닌)인지 인증 할 수 있는 기능을 가진다.<br/>
ex 신한은행에서 신한은행 비밀키로 암호화해서 자신이 문서를 보내려는 고객에게 보낸다.
고객은 공개키로 문서를 복호화해서 문자가 정상적으로 해독이 되어 사용한다.<br/>
-> 이때 알 수 있는것<br/>
1) 복호화가 되는순간 이 문서는 신한은행에서 보낸것이라는 것을 확인 가능 (비밀키를 가진사람은 신한은행밖에 없으니까)
2) 여전히 신한은행의 비밀키는 유출될 가능성이 없음 (만약 해커가 암호알고리즘을 뚫는것이 아니라면)
3) 이게 인증서 역할임
   <br/>


단점
- 대칭키에 비해 속도가 느리다.

[비대칭키 실제로 작동시켜보기](https://www.devglan.com/online-tools/rsa-encryption-decryption)


# HTTPS(SSL) 인증서 살펴보기

### SSL 인증서의 목표
접속한 서버가 신뢰할 수 있는지 보장하는 역할

SSL 통신에 사용할 공개키를 클라이언트에게 제공

![](https://velog.velcdn.com/images/tkdtkd97/post/96d2581a-f1bc-46d6-93fc-5116c50d8b2f/image.png)
> 인증서에 담겨있는 내용은 뭘까?
인증서를 발급한 CA기관, 서버 측의 공개키 그 외 인증서의 유효기간, 기타 정보들이 있다.


### CA(Certificate Authority) 기관이란?
![](https://velog.velcdn.com/images/tkdtkd97/post/100a5df7-01d7-41a1-a218-7ed01c512716/image.png)

대부분 민간 기업들이 수행하고 클라이언트가 접속한 서버가 의도한 서버인지 보장하는 기관이다.

### SSL handshake 동작 중 인증서의 의미
서버는 클라이언트와 통신하는 과정에서 인증서를 클라이언트에게 전달해야한다. 이 작업은 여러가지 의미를 같는다.

1. 자신의 서버가 CA기관이라는 검증된 기관에서 안전하다고 판단한 서버라는 것을 클라이언트에게 알린다.
2. CA기관에서 준 인증서에 서버의 공유키를 넣어서 클라이언트에게 전달 할 수 있게 된다.

### SSL handshake 동작 전에 서버가 CA기관으로부터 인증서를 발급받는 과정
![](https://velog.velcdn.com/images/tkdtkd97/post/4544f943-95a6-45c0-88bf-8c555a2fbb10/image.png)

인증서를 발급하는 과정에서 비대칭키 방식이 쓰인다.
이 행위를 함으로써
1. 서버는 자신의 공개키를 인증서에 동봉하기 위해 그림의 1번에서 공개키를 전달한다.
> SSL 인증서에는 주로 서버의 공개키가 들어가 있는데, 이는 나중에 데이터 교환을 위한 대칭키 전달에 사용된다.

2. CA기관은 인증서를 만들면서 인증서가 조작되지 않고 CA기관에서 만든것을 증명하기 위해 그림의 3번에서 CA기관 비밀키로 암호화를한다.

추후에 클라이언트는 CA기관의 비밀키로 암호화된 인증서를 받고 CA기관으로부터 검증받는 과정에서 CA공개키를 받아 정상적으로 복호화되는지 확인(CA가 발급한게 맞는지 확인한다.)
> 비대칭키의 장점 두번째 인증서역할을 볼 수 있다.


# SSL handshake 과정
### SSL handshake 특징

신뢰할 수 있는 서버임이 인증되었다면, 서버와 브라우저가 서로 어떤 알고리즘과 대칭키로 데이터를 암호화하여 주고 받을지 협상이 필요하다.

이 과정은 전송 계층(Transport Layer)인 TCP 연결이 수립된 후, SSL/TLS 프로토콜에서 SSL Handshake을 통해 결정된다.

> SSL Handshake은 데이터를 실제로 암호화 하기 위한 대칭키를 전달하는 것이 가장 큰 목적이다.

### SSL handshake 단계별 설명
![](https://velog.velcdn.com/images/tkdtkd97/post/ea416071-1030-4416-a03b-af990d5c8292/image.png)


#### Client Hello
서버에게 브라우저의 SSL버전정보를 알린다.

사용가능한 암호 알고리즘 리스트를 전달한다.

브라우저가 생성한 난수를 전달한다.

#### Server Hello
Client Hello에서 받은 브라우저가 사용가능하다고한 알고리즘 리스트를 보고 통신에 사용할 암호 알고리즘을 정한다.

사전에 CA기관으로 부터 발급받은 인증서(서버의 공개키가 들어있음)를 클라이언트에게 전달한다.

서버에서도 난수를 하나 생성해서 보낸다.

#### 서버 인증서 확인
![](https://velog.velcdn.com/images/tkdtkd97/post/a215f305-0e76-4d94-9106-b09509dd1250/image.png)
클라이언트는 서버로부터 인증서를 받고 CA기관에 검증을 받는다.
> 이 과정에서 비대칭키 방식이 사용된다.

Premaster Secret을 생성
서로가 만든 난수들을 가지고 대칭키를 생성한다.
> f(클라이언트가 만든 난수, 서버가 만든 난수) 이 함수를 통해 나온 문자열이 통신하는 과정에서 사용될 대칭키가 된다.

> 실제 대칭키 예시
MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIAtICH+utufya73X6rELiVi6rjR+jHBMNBhiqp2fOR/sUw7CEn6PNsp6OjcB9ZemWlxs/bAoLwt7Uba1fJT+FPS2AECIUJv8yYo1Y9jLX45Mf5mKTz9Fwuo9kw

이렇게 만든 Premaster Secret를 인증서에서 받은 공개키로 암호화해서 서버에 전달한다.
> 비대칭키 방식 사용

#### Premaster Secret 복호화
클라이언트가 보낸 Premaster Secret를 서버는 자신의 비밀키로 Premaster Secret를 복호화해서 통신에 사용한다.
> 비대칭키 방식으로 통신에 사용될 키(대칭키)를 안전하게 전달받았다.

### 정리
#### 암호화 방식 사용

실제 데이터 -> 대칭키로 암호화

대칭키의 키 -> 서버의 비대칭키로 암호화해서 전달


#### SSL 기반 통신 과정

1. 악수(3-way handshake)
> 3-way handshake(TCP의 접속) vs 4-way handshake(TCP의 접속 해제)
4-way handshake
![](https://velog.velcdn.com/images/tkdtkd97/post/ca5bdca4-010e-4bed-af5a-13b2ac74c478/image.png)


2. 데이터 전송

3. 세션 종료


### 왜 대칭키랑 비대칭키 두개를 섞어서 쓰나
대칭키는 빠르지만, 보안에 취약하다.

비대칭키는 이상적이지만, 비용이 많이 든다.
> 그래서 비대칭키를 이용해서 실제 데이터 전송에 사용되는 대칭키를 안전하게 전달한다.

# 참고
https://velog.io/@ann0905/HTTPS-2.-HTTPS%EC%99%80-SSL-Handshake
https://www.youtube.com/watch?v=FMqkkohAS9c&list=PLRUS1nW-CfneHE_Ajr-iYMdyuCUIp1e_r&index=4

# 면접 예상질문
> 1. HTTP와 HTTPS의 차이점에 대해서 설명해보세요.

HTTP는 따로 암호화 과정을 거치지 않기 때문에 중간에 패킷을 가로챌 수 있고, 수정할 수 있어 보안이 취약합니다. 이를 보완하기 위해 나온 것이 HTTP에서 중간에 암호화 계층을 더하여 패킷을 암호화한 HTTPS입니다.

> 2. 대칭키와 비대칭키의 장단점을 말해주세요

대칭키와 비대칭키를 비교해서 설명하면

대칭키는 비대칭키에 비해 전달 속도가 빠른대신 통신하는 과정에서 대칭키를 직접 전달하기 때문에 키가 탈취될 가능성이 있습니다.

비대칭키는 대칭키에 비해 속도는 느리지만 키를 쌍으로 생성해서 공유키는 모두 볼 수 있게 하고 비밀키는 자신만 가지고있어 대칭키방식처럼 키가 탈취될 위험부담이 없습니다. 추가로 인증서 역할을 수행할수있습니다.

> 2번 추가 질문) SSL 작동할때 대칭키와 비대칭키를 모두 사용한다고 생각하나요?

대칭키에 비해 비대칭키 방식은 키가 탈취될 가능성이 없어 보안적으로 안전하다는 장점이 있습니다. 하지만 그렇다고 모든 통신을 비대칭키로 한다면 통신하는 시간이 다소 길어질 수 있습니다. 그래서 이 통신시간을 줄이기위해 데이터를 통신할때 암호화와 복호화는 대칭키를 생성하여 진행하고 최초에 이 대칭키를 상대에게 전달할때는 비대칭키로 전달하여 서로의 장점을 살리고 단점을 보완하기 때문입니다.


> 3. SSL handshake 과정을 설명해보세요

1. 클라이언트는 서버에게 client hello 메시지를 담아 서버로 보낸다. 이때 암호화된 정보를 함께 담는데, 버전, 암호 알고리즘, 압축 방식 등을 담는다.

2. 서버는 클라이언트가 보낸 암호 알고리즘과 압축 방식을 받고, 세션 ID와 CA 공개 인증서를 server hello 메시지와 함께 담아 응답한다. 이 CA 인증서에는 앞으로 통신 이후 사용할 대칭키가 생성되기 전, 클라이언트에서 handshake 과정 속 암호화에 사용할 공개키를 담고 있다.

3. 클라이언트 측은 서버에서 보낸 CA 인증서에 대해 유효한 지 CA 목록에서 확인하는 과정을 진행한다.

4. CA 인증서에 대한 신뢰성이 확보되었다면, 클라이언트는 난수 바이트를 생성하여 서버의 공개키로 암호화한다. 이 난수 바이트는 대칭키를 정하는데 사용이 되고, 앞으로 서로 메시지를 통신할 때 암호화하는데 사용된다.

5. 만약 2번 단계에서 서버가 클라이언트 인증서를 함께 요구했다면, 클라이언트의 인증서와 클라이언트의 개인키로 암호화된 임의의 바이트 문자열을 함께 보내준다.

6. 서버는 클라이언트의 인증서를 확인 후, 난수 바이트를 자신의 개인키로 복호화 후 대칭 마스터 키 생성에 활용한다.

7. 클라이언트는 handshake 과정이 완료되었다는 finished 메시지를 서버에 보내면서, 지금까지 보낸 교환 내역들을 해싱 후 그 값을 대칭키로 암호화하여 같이 담아 보내준다.

8. 서버도 동일하게 교환 내용들을 해싱한 뒤 클라이언트에서 보내준 값과 일치하는 지 확인한다. 일치하면 서버도 마찬가지로 finished 메시지를 이번에 만든 대칭키로 암호화하여 보낸다.

9. 클라이언트는 해당 메시지를 대칭키로 복호화하여 서로 통신이 가능한 신뢰받은 사용자란 걸 인지하고, 앞으로 클라이언트와 서버는 해당 대칭키로 데이터를 주고받을 수 있게 된다.