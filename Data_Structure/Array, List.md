## Array

**고정된 크기의 연속된** 메모리 공간에 **순차적**으로 **같은 타입**의 데이터를 나열한 **선형 자료구조**

---

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1274461e-1b48-40cb-acfc-f2a6bef807af/Untitled.png)

### 특징

1. 선언할 때 크기와 데이터 타입을 지정해야 한다
- 크기는 고정, 데이터 타입은 동일
1. 메모리 상에 데이터가 순차적으로 저장
- 배열의 각각의 요소에 index 존재
- 인덱스를 통해 배열의 요소에 접근 가능
1. 연속된 메모리에 단일 블록화하여 데이터 저장
- 낭비되는 공간이 없음
1. 삽입 순서대로 저장됨
2. 동일한 값도 저장 가능 (중복 허용)
3. 삽입, 삭제, 검색 연산 지원

### 장점

1. 구현이 쉬움
2. 인덱스를 통한 접근이 가능하기 때문에 원하는 요소에 빠르게 접근 가능
3. 메모리를 효율적으로 사용 가능

### 단점

1. 크기를 변경할 수 없음
2. 중간 요소를 삭제할 경우, 뒤에 있는 데이터를 삭제한 요소 수만큼 이동해야함
3. 배열의 중간에 요소를 삽입 할 경우, 뒤에 있는 데이터를 삽입한 요소 수만큼 이동해야함

### Array를 사용하는 경우

- 순차적인 데이터를 저장할 때
- 특정 요소를 빠르게 검색할 때
- 데이터의 크기가 일정할 때
- 데이터를 수정하는 빈도가 낮을 때

## List

**배열의 단점을 해결하여** 데이터를 나열한 **크기가 가변적인** 선형 자료구조

---

### 배열과 다른 특징

- 크기가 가변적이다
    - 데이터를 담을 공간의 추가가 가능
- 데이터가 연결되어 있다
    - 중간이 비어있으면 안됨

<aside>
💡 메모리를 효율적으로 사용 가능

</aside>

### 1. 순차 리스트(Sequential List)

배열과 비슷

- 자료들을 순차적인 메모리 공간안에 연속하여 저장하는 자료구조
- 빈 공간이 없이 순서대로 저장됨
- 인덱스를 가짐
- 탐색에는 좋으나 추가, 삭제에서는 상대적으로 효율이 떨어짐
- 물리적 순서와 논리적 순서가 동일 → 탐색에 유리

### ArrayList

내부적으로 배열을 사용하여 데이터를 연속적으로 저장

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7af07300-5edb-4944-ab99-76836a4e6c15/Untitled.png)

### 특징

- 크기가 가변적인 배열
- 배열의 크기를 동적으로 조절할 수 있음
- 내부적으론 배열로 이루어져 있기 때문에 인덱스를 가짐
- 요소들이 순서대로 저장되는 선형 자료구조

### 장점

- 내부적으로 배열을 사용하기 때문에 인덱스를 사용하여 접근이 빠름
- 크기가 가변적임
- 데이터를 순차적으로 저장하기 때문에 데이터에 대한 연산, 검색에 유용

### 단점

- 데이터를 삭제나 삽입할 때 배열 내부적으로 데이터를 이동시켜야 하기 때문에 느릴 수 있음

### 2. 연결 리스트(LinkedList) - 단일 연결 리스트(Singly Linked List)

각 노드가 데이터와 다음 노드에 대한 포인터(주소)를 가지고 연결되어 있는 방식

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d70562e5-ccbc-43db-806b-e21cc00dff7d/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cb9ed731-9ad6-4d0d-bdaa-afb2aef1de92/Untitled.png)

> 시작이 되는 node : Head, 마지막 node : Tail
> 

### 특징 (장단점)

- **데이터의 삭제나 삽입이 효율적이다**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/349c1372-2161-41b4-864c-ac8a05c95f9f/Untitled.png)

- 배열과는 다르게 메모리상에 데이터가 연속적이지는 않는다
- 데이터를 저장할 때마다 동적으로 메모리를 할당
- 첫 번째 요소의 위치만 알고 있어도 나머지 요소의 위치를 알 수 있다
    - 리스트를 완전 종주하려면 항상 첫번째 요소부터 시작해야함
    - 모든 원소의 위치를 파악하기 위해서는 리스트의 첫번째 요소에 대한 포인터나 레퍼런스가 있어야만 함

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23d3be57-b9bf-4c1e-ab1e-1db354162ff1/Untitled.png)

- 배열과 다르게 인덱스가 없기 때문에 접근이 어렵다
    - 특정 위치의 요소를 찾기 위해서는 리스트의 첫 번째 요소부터 순차적으로 접근해야함
- 메모리 사용량 측면에서는 데이터와 위치정보를 저장해야 하기 때문에 좋지 않다
- 하지만 데이터를 추가/삭제 할 때는 노드를 생성해서 연결하거나 삭제하여 노드를 연결시켜주기만 하면 되기 때문에 메모리를 효율적으로 사용할 수 있다

### LinkedList의 다른 종류

**이중 연결 리스트 (Doubly Linked List)**

**각 노드가 자신의 이전 노드와 다음 노드의 주소를 둘다 저장하고 있는 연결리스트**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/78e73f07-e09a-405f-9630-b6274dc1e091/Untitled.png)

- 단일 연결리스트와는 다르게 각 요소의 이전 위치와 다음 위치를 둘다 알 수 있다
- 메모리를 더 사용하고 불필요하게 복잡해진다

**원형 연결 리스트 (Circularly Linked List)**

**가장 마지막 노드가 첫번 째 노드의 주소를 저장하고 있는 연결리스트**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b5093ad7-7e59-4a93-bcd6-3d15a650ad2c/Untitled.png)

- 마지막 노드가 Null이 아닌 첫번째 노드의 주소를 가리킴
- 처음과 끝이 연결되어있는 형태
- 머리와 꼬리가 없음

### 예상질문

1. Array와 LinkedList의 차이를 설명해주세요
2. ArrayList와 LinkedList의 차이를 설명해주세요
3. LinkedList의 종류에 대해서 각각 간단하게 설명해주세요
4. List와 Set의 차이에 대해서 설명해주세요
